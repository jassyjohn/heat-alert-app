<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="CA Heat Alert">
<title>California Heat Health Alert</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
/* Password gate */
.pw-gate {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: #1a1a2e; z-index: 9999;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
}
.pw-gate h2 { color: #eee; margin-bottom: 16px; font-size: 1.2em; }
.pw-gate input {
    padding: 12px 16px; border: 2px solid #333; border-radius: 10px;
    background: #16213e; color: #fff; font-size: 1em; text-align: center;
    outline: none; width: 220px;
}
.pw-gate input:focus { border-color: #e94560; }
.pw-gate button {
    margin-top: 10px; padding: 10px 28px; border: none; border-radius: 10px;
    background: #e94560; color: #fff; font-size: 1em; font-weight: 600; cursor: pointer;
}
.pw-gate .pw-error { color: #e94560; font-size: 0.85em; margin-top: 8px; min-height: 1.2em; }
.app-content { display: none; }
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: #1a1a2e;
    color: #eee;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
}
.header {
    width: 100%;
    padding: 20px;
    text-align: center;
    background: linear-gradient(135deg, #16213e, #0f3460);
}
.header h1 { font-size: 1.3em; font-weight: 600; }
.header p { font-size: 0.8em; color: #aaa; margin-top: 4px; }

.search-box {
    width: 90%;
    max-width: 400px;
    margin: 20px auto;
    display: flex;
    gap: 8px;
}
.search-box input {
    flex: 1;
    padding: 14px 16px;
    border: 2px solid #333;
    border-radius: 12px;
    background: #16213e;
    color: #fff;
    font-size: 1.1em;
    text-align: center;
    letter-spacing: 2px;
    outline: none;
}
.search-box input:focus { border-color: #e94560; }
.search-box input::placeholder { color: #666; letter-spacing: normal; }
.search-box button {
    padding: 14px 20px;
    border: none;
    border-radius: 12px;
    background: #e94560;
    color: #fff;
    font-size: 1em;
    font-weight: 600;
    cursor: pointer;
}
.search-box button:active { background: #c73651; }

.status-msg {
    text-align: center;
    padding: 10px 20px;
    font-size: 0.9em;
    color: #aaa;
}
.status-msg.error { color: #e94560; }

/* Current conditions card */
.current-card {
    width: 90%;
    max-width: 400px;
    margin: 10px auto;
    padding: 24px;
    border-radius: 16px;
    text-align: center;
    display: none;
}
.current-card .temp {
    font-size: 4em;
    font-weight: 700;
    line-height: 1;
}
.current-card .label {
    font-size: 1.1em;
    font-weight: 600;
    margin-top: 8px;
}
.current-card .sublabel {
    font-size: 0.85em;
    color: rgba(255,255,255,0.7);
    margin-top: 4px;
}

/* Category colors */
.cat-none { background: linear-gradient(135deg, #2d6a4f, #40916c); }
.cat-1 { background: linear-gradient(135deg, #b8860b, #daa520); }
.cat-2 { background: linear-gradient(135deg, #cc5500, #e67300); }
.cat-3 { background: linear-gradient(135deg, #cc0000, #e63946); }
.cat-4 { background: linear-gradient(135deg, #800020, #a3001e); }

/* Threshold gauge */
.gauge {
    width: 90%;
    max-width: 400px;
    margin: 15px auto;
    display: none;
}
.gauge h3 {
    font-size: 0.9em;
    color: #aaa;
    margin-bottom: 10px;
    text-align: center;
}
.gauge-bar {
    height: 40px;
    border-radius: 20px;
    display: flex;
    overflow: hidden;
    position: relative;
    background: #2d6a4f;
}
.gauge-segment {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7em;
    font-weight: 600;
    color: rgba(255,255,255,0.9);
    position: relative;
}
.seg-none { background: #40916c; }
.seg-1 { background: #daa520; }
.seg-2 { background: #e67300; }
.seg-3 { background: #e63946; }
.seg-4 { background: #a3001e; }

.gauge-marker {
    position: absolute;
    top: -8px;
    width: 4px;
    height: 56px;
    background: #fff;
    border-radius: 2px;
    z-index: 10;
    box-shadow: 0 0 8px rgba(255,255,255,0.8);
}

/* Threshold table */
.thresholds {
    width: 90%;
    max-width: 400px;
    margin: 15px auto;
    display: none;
}
.thresholds h3 {
    font-size: 0.9em;
    color: #aaa;
    margin-bottom: 10px;
    text-align: center;
}
.threshold-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    margin: 4px 0;
    border-radius: 10px;
    font-size: 0.95em;
    cursor: pointer;
    transition: outline 0.15s;
}
.threshold-row:hover { outline: 2px solid rgba(255,255,255,0.5); }
.threshold-row.map-active { outline: 3px solid #fff; }
.threshold-row .cat-name { font-weight: 600; }
.threshold-row .cat-temp { font-weight: 500; opacity: 0.9; }
.threshold-row .cat-ci { font-size: 0.75em; opacity: 0.65; font-weight: 400; }

/* Map */
.map-container {
    width: 95%;
    max-width: 600px;
    margin: 15px auto;
    display: none;
}
.map-container h3 {
    font-size: 0.9em;
    color: #aaa;
    margin-bottom: 10px;
    text-align: center;
}
#map {
    height: 400px;
    border-radius: 12px;
    border: 2px solid #333;
}
.map-legend {
    display: flex;
    justify-content: center;
    gap: 8px;
    margin-top: 8px;
    flex-wrap: wrap;
}
.legend-item {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 0.7em;
    color: #aaa;
}
.legend-swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
}

/* Forecast section */
.forecast {
    width: 90%;
    max-width: 400px;
    margin: 15px auto 30px;
    display: none;
}
.forecast h3 {
    font-size: 0.9em;
    color: #aaa;
    margin-bottom: 10px;
    text-align: center;
}
.forecast-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
    gap: 8px;
}
.forecast-day {
    padding: 10px 6px;
    border-radius: 10px;
    text-align: center;
}
.forecast-day .day-name { font-size: 0.75em; color: rgba(255,255,255,0.7); }
.forecast-day .day-temp { font-size: 1.3em; font-weight: 700; margin: 4px 0; }
.forecast-day .day-cat { font-size: 0.7em; font-weight: 600; }

.footer {
    width: 100%;
    padding: 20px;
    text-align: center;
    font-size: 0.7em;
    color: #555;
    margin-top: auto;
}
</style>
</head>
<body>

<div id="pwGate" class="pw-gate">
    <h2>California Heat Health Alert</h2>
    <input type="password" id="pwInput" placeholder="Enter password" autofocus>
    <button onclick="checkPassword()">Enter</button>
    <div class="pw-error" id="pwError"></div>
</div>

<div id="appContent" class="app-content">
<div class="header">
    <h1>California Heat Health Alert</h1>
    <p>ZIP-level heat thresholds + live weather</p>
</div>

<div class="search-box">
    <input type="text" id="zipInput" placeholder="Enter CA ZIP code"
           maxlength="5" inputmode="numeric" pattern="[0-9]*">
    <button onclick="lookupZip()">Go</button>
</div>

<div id="statusMsg" class="status-msg"></div>

<div id="currentCard" class="current-card">
    <div class="temp" id="currentTemp">--°F</div>
    <div class="label" id="currentCat">--</div>
    <div class="sublabel" id="currentDesc">--</div>
</div>

<div id="mapContainer" class="map-container">
    <h3 id="mapTitle">Cat 4 Threshold Map — Neighboring ZIPs</h3>
    <div id="map"></div>
    <div class="map-legend" id="mapLegend"></div>
</div>

<div id="gauge" class="gauge">
    <h3>Your ZIP's Heat Thresholds</h3>
    <div class="gauge-bar" id="gaugeBar"></div>
</div>

<div id="thresholds" class="thresholds">
    <h3>Threshold Details</h3>
    <div id="thresholdRows"></div>
</div>

<div id="forecast" class="forecast">
    <h3>7-Day Forecast</h3>
    <div class="forecast-grid" id="forecastGrid"></div>
</div>

<div class="footer">
    SuperDuper Heat Warning System<br>
    Weather: National Weather Service API
</div>
</div><!-- end app-content -->

<script>
// ---- Password gate ----
// SHA-256 hash of the password (not stored in plain text)
const PW_HASH = 'fda024085d4d0bd1fe98e21cf28259e9aafada9d339f72a5ea45f983f08d5ffd';

async function sha256(str) {
    const buf = await crypto.subtle.digest('SHA-256',
        new TextEncoder().encode(str));
    return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function checkPassword() {
    const input = document.getElementById('pwInput').value;
    const hash = await sha256(input);
    if (hash === PW_HASH) {
        document.getElementById('pwGate').style.display = 'none';
        document.getElementById('appContent').style.display = 'block';
        sessionStorage.setItem('pw_ok', '1');
    } else {
        document.getElementById('pwError').textContent = 'Incorrect password';
        document.getElementById('pwInput').value = '';
        document.getElementById('pwInput').focus();
    }
}

// Allow Enter key on password field
document.getElementById('pwInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') checkPassword();
});

// Remember within session
if (sessionStorage.getItem('pw_ok') === '1') {
    document.getElementById('pwGate').style.display = 'none';
    document.getElementById('appContent').style.display = 'block';
}
</script>

<script>
// Threshold data will be loaded from external JSON file
let THRESHOLDS = null;

// Load thresholds from JSON file (same directory)
async function loadThresholds() {
    try {
        const resp = await fetch('zip_thresholds.json');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        THRESHOLDS = await resp.json();
        // Detect number of categories from first ZIP entry
        const firstZip = Object.values(THRESHOLDS)[0];
        if (firstZip && firstZip.n_cats) {
            N_CATS = firstZip.n_cats;
        } else {
            // Count cat1, cat2, cat3, ... keys
            N_CATS = 0;
            while (firstZip[`cat${N_CATS + 1}`] != null) N_CATS++;
        }
        currentMapCat = `cat${N_CATS}`;
        console.log(`Loaded ${Object.keys(THRESHOLDS).length} ZIP thresholds (${N_CATS} categories)`);
    } catch (e) {
        console.error('Failed to load thresholds:', e);
        showStatus('Failed to load threshold data. Make sure zip_thresholds.json is in the same directory.', true);
    }
}

// Load on page load
loadThresholds();

// Enter key triggers lookup
document.getElementById('zipInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') lookupZip();
});

function showStatus(msg, isError) {
    const el = document.getElementById('statusMsg');
    el.textContent = msg;
    el.className = isError ? 'status-msg error' : 'status-msg';
}

// Number of threshold categories (read from data, default 3)
let N_CATS = 3;

function getCategory(temp, t) {
    for (let c = N_CATS; c >= 1; c--) {
        if (temp >= t[`cat${c}`]) return c;
    }
    return 0;
}

const CAT_NAMES = ['Below Threshold', 'Category 1 - Moderate',
        'Category 2 - High', 'Category 3 - Extreme'];

function catName(cat) {
    return CAT_NAMES[cat] || `Category ${cat}`;
}

function catClass(cat) {
    return cat === 0 ? 'cat-none' : `cat-${cat}`;
}

async function lookupZip() {
    const zip = document.getElementById('zipInput').value.trim();
    if (!/^\d{5}$/.test(zip)) {
        showStatus('Please enter a valid 5-digit ZIP code', true);
        return;
    }

    if (!THRESHOLDS) {
        showStatus('Threshold data not loaded yet. Please wait...', true);
        return;
    }

    const t = THRESHOLDS[zip];
    if (!t) {
        showStatus(`ZIP ${zip} not found in California threshold data`, true);
        return;
    }

    showStatus('Fetching weather data...', false);

    // Show thresholds immediately
    showThresholds(t);

    // Fetch weather from NWS
    try {
        const weather = await fetchNWSWeather(t.lat, t.lon);
        const cat = getCategory(weather.current.temp, t);
        showCurrentConditions(weather.current, t, zip);
        showMap(t.lat, t.lon, zip, cat);
        showForecast(weather.forecast, t);
        showGauge(weather.current.temp, t);
        showStatus('', false);
    } catch (e) {
        console.error('Weather fetch error:', e);
        showStatus('Weather data unavailable. Showing thresholds only.', true);
        showMap(t.lat, t.lon, zip, 0);
        // Still show thresholds even without weather
        document.getElementById('currentCard').style.display = 'none';
        document.getElementById('forecast').style.display = 'none';
        document.getElementById('gauge').style.display = 'none';
    }
}

async function fetchNWSWeather(lat, lon) {
    // Step 1: Get grid point
    const pointResp = await fetch(
        `https://api.weather.gov/points/${lat},${lon}`,
        { headers: { 'User-Agent': 'CAHeatAlert/1.0 (OEHHA research prototype)' } }
    );
    if (!pointResp.ok) throw new Error(`NWS points: ${pointResp.status}`);
    const pointData = await pointResp.json();

    // Step 2: Get forecast
    const fcResp = await fetch(
        pointData.properties.forecast,
        { headers: { 'User-Agent': 'CAHeatAlert/1.0 (OEHHA research prototype)' } }
    );
    if (!fcResp.ok) throw new Error(`NWS forecast: ${fcResp.status}`);
    const fcData = await fcResp.json();

    // Parse periods — NWS gives day/night pairs
    const periods = fcData.properties.periods;
    const forecast = [];
    let currentTemp = null;
    let currentDesc = '';

    for (const p of periods) {
        const tempF = p.temperatureUnit === 'F' ? p.temperature :
                      p.temperature * 9/5 + 32;

        if (currentTemp === null) {
            currentTemp = tempF;
            currentDesc = p.shortForecast;
        }

        if (p.isDaytime) {
            forecast.push({
                name: p.name,
                temp: tempF,
                desc: p.shortForecast,
            });
        }
    }

    return {
        current: { temp: currentTemp, desc: currentDesc },
        forecast: forecast.slice(0, 7),
    };
}

function showCurrentConditions(current, t, zip) {
    const card = document.getElementById('currentCard');
    const cat = getCategory(current.temp, t);

    document.getElementById('currentTemp').textContent = `${Math.round(current.temp)}°F`;
    document.getElementById('currentCat').textContent = catName(cat);
    document.getElementById('currentDesc').textContent =
        `ZIP ${zip} — ${current.desc}`;

    card.className = `current-card ${catClass(cat)}`;
    card.style.display = 'block';
}

function showGauge(currentTemp, t) {
    const gauge = document.getElementById('gauge');
    const bar = document.getElementById('gaugeBar');

    // Gauge range: 70°F to max(top_cat+10, currentTemp+5)
    const lo = 70;
    const topCatTemp = t[`cat${N_CATS}`];
    const hi = Math.max(topCatTemp + 10, (currentTemp || 0) + 5, 110);
    const range = hi - lo;

    const pct = (v) => Math.max(0, Math.min(100, (v - lo) / range * 100));

    // Build segments dynamically
    const segments = [
        { end: t.cat1, cls: 'seg-none', label: `<${Math.round(t.cat1)}°` },
    ];
    for (let c = 1; c < N_CATS; c++) {
        segments.push({ end: t[`cat${c+1}`], cls: `seg-${c}`, label: `Cat ${c}` });
    }
    segments.push({ end: hi, cls: `seg-${N_CATS}`, label: `Cat ${N_CATS}` });

    let html = '';
    let prevEnd = lo;
    for (const seg of segments) {
        const w = pct(seg.end) - pct(prevEnd);
        if (w > 0) {
            html += `<div class="gauge-segment ${seg.cls}" style="width:${w}%">
                ${w > 8 ? seg.label : ''}</div>`;
        }
        prevEnd = seg.end;
    }

    // Current temp marker
    if (currentTemp != null) {
        const markerPct = pct(currentTemp);
        html += `<div class="gauge-marker" style="left:${markerPct}%"></div>`;
    }

    bar.innerHTML = html;
    gauge.style.display = 'block';
}

function showThresholds(t) {
    const container = document.getElementById('thresholdRows');
    const cats = [];
    for (let c = 1; c <= N_CATS; c++) {
        cats.push({
            num: c, key: `cat${c}`, name: catName(c),
            temp: t[`cat${c}`], lo: t[`ci_lo${c}`], hi: t[`ci_hi${c}`],
        });
    }

    container.innerHTML = cats.map(c => {
        const ciText = (c.lo != null && c.hi != null)
            ? `<span class="cat-ci">(${c.lo.toFixed(1)}–${c.hi.toFixed(1)})</span>`
            : '';
        const active = c.key === currentMapCat ? ' map-active' : '';
        return `<div class="threshold-row ${catClass(c.num)}${active}" data-cat="${c.key}"
                     onclick="updateMapCategory('${c.key}')">
            <span class="cat-name">${c.name}</span>
            <span class="cat-temp">${c.temp.toFixed(1)}°F ${ciText}</span>
        </div>`;
    }).join('');

    document.getElementById('thresholds').style.display = 'block';
}

// ---- Map ----
let map = null;
let geoLayer = null;
let zipPolygons = null;  // cached GeoJSON
let selectedZip = null;
let currentMapCat = `cat${N_CATS}`;  // default to highest category

function getCatLabel(catKey) {
    const n = parseInt(catKey.replace('cat', ''));
    return catName(n);
}

// RdYlBu_r color scale matching ZIP threshold maps (blue->cream->red)
// 11 stops sampled from chroma.scale(['#313695','#74add1','#ffffbf','#f46d43','#a50026'])
const rdYlBuR = ['#313695','#4575b4','#74add1','#abd9e9','#e0f3f8',
                 '#ffffbf','#fee090','#fdae61','#f46d43','#d73027','#a50026'];

// Per-category breakpoints (will be recomputed from data once loaded)
const colorScales = {
    cat1: { breaks: [71, 74, 77, 80, 83, 86, 89, 92, 95, 98, 100] },
    cat2: { breaks: [72, 75, 78, 81, 85, 88, 91, 94, 97, 100, 103] },
    cat3: { breaks: [73, 77, 80, 84, 88, 92, 96, 100, 104, 108, 111] },
};

function thresholdColor(val) {
    if (val == null) return '#999';
    const scale = colorScales[currentMapCat];
    for (let i = 0; i < scale.breaks.length; i++) {
        if (val <= scale.breaks[i]) return rdYlBuR[i];
    }
    return rdYlBuR[rdYlBuR.length - 1];
}

function updateLegend() {
    const scale = colorScales[currentMapCat];
    // Show every other break for a compact legend
    const picks = [0, 2, 4, 6, 8, 10];
    const html = picks.map(i =>
        `<div class="legend-item"><div class="legend-swatch" style="background:${rdYlBuR[i]}"></div>${Math.round(scale.breaks[i])}°F</div>`
    ).join('');
    document.getElementById('mapLegend').innerHTML = html;
}

function updateMapCategory(catKey) {
    currentMapCat = catKey;
    // Update title and legend
    document.getElementById('mapTitle').textContent =
        `${getCatLabel(catKey)} Threshold Map — Neighboring ZIPs`;
    updateLegend();
    // Re-style polygons
    if (geoLayer) {
        geoLayer.eachLayer(layer => {
            const p = layer.feature.properties;
            const isSelected = p.zip === selectedZip;
            layer.setStyle({
                fillColor: thresholdColor(p[catKey]),
                fillOpacity: isSelected ? 0.9 : 0.7,
                color: isSelected ? '#fff' : 'transparent',
                weight: isSelected ? 3 : 0,
            });
            if (isSelected) layer.bringToFront();
        });
    }
    // Highlight active row
    document.querySelectorAll('.threshold-row').forEach(row => {
        row.classList.toggle('map-active', row.dataset.cat === catKey);
    });
}

async function loadPolygons() {
    if (zipPolygons) return zipPolygons;
    const resp = await fetch('zip_polygons.geojson');
    if (!resp.ok) throw new Error(`GeoJSON: ${resp.status}`);
    zipPolygons = await resp.json();
    console.log(`Loaded ${zipPolygons.features.length} ZIP polygons`);
    return zipPolygons;
}

function showMap(lat, lon, zip, cat) {
    const container = document.getElementById('mapContainer');
    container.style.display = 'block';
    document.getElementById('mapTitle').textContent =
        `${getCatLabel(currentMapCat)} Threshold Map — Neighboring ZIPs`;
    updateLegend();

    if (!map) {
        map = L.map('map', { zoomControl: true, attributionControl: false });
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
            opacity: 0.4,
        }).addTo(map);
        L.control.attribution({ prefix: false })
            .addAttribution('&copy; OpenStreetMap')
            .addTo(map);
    }

    selectedZip = zip;
    map.setView([lat, lon], 9);

    // Load and render choropleth
    loadPolygons().then(geojson => {
        if (geoLayer) map.removeLayer(geoLayer);

        geoLayer = L.geoJSON(geojson, {
            style: function(feature) {
                const isSelected = feature.properties.zip === zip;
                return {
                    fillColor: thresholdColor(feature.properties[currentMapCat]),
                    fillOpacity: isSelected ? 0.9 : 0.7,
                    color: isSelected ? '#fff' : 'transparent',
                    weight: isSelected ? 3 : 0,
                };
            },
            onEachFeature: function(feature, layer) {
                const p = feature.properties;
                const isSelected = p.zip === zip;
                let popupLines = `<b>ZIP ${p.zip}</b>${isSelected ? ' (selected)' : ''}`;
                for (let c = 1; c <= N_CATS; c++) {
                    if (p[`cat${c}`] != null) popupLines += `<br>Cat ${c}: ${p[`cat${c}`]}°F`;
                }
                layer.bindPopup(popupLines, { closeButton: true, autoClose: true });
            },
        }).addTo(map);

        // Bring selected ZIP to front
        geoLayer.eachLayer(layer => {
            if (layer.feature.properties.zip === zip) {
                layer.bringToFront();
            }
        });

        setTimeout(() => map.invalidateSize(), 100);
    }).catch(err => {
        console.error('Failed to load polygons:', err);
    });
}

function showForecast(forecast, t) {
    const grid = document.getElementById('forecastGrid');
    grid.innerHTML = forecast.map(day => {
        const cat = getCategory(day.temp, t);
        return `<div class="forecast-day ${catClass(cat)}">
            <div class="day-name">${day.name}</div>
            <div class="day-temp">${Math.round(day.temp)}°</div>
            <div class="day-cat">${cat > 0 ? 'Cat ' + cat : 'OK'}</div>
        </div>`;
    }).join('');

    document.getElementById('forecast').style.display = 'block';
}
</script>

</body>
</html>
